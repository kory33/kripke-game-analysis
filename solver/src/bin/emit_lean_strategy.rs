extern crate kripke_game_solver;

use kripke_game_solver::formula::Formula;
use kripke_game_solver::offical_game_solver::{
    OfficialGamePropVar, StrategyAgainstFixedWorldCount, come_up_with_strategy,
};
use std::io::{self, Write};

/// Convert a Rust formula to Lean ModalFormula syntax
fn formula_to_lean(f: &Formula<OfficialGamePropVar>) -> String {
    match f {
        Formula::Var(v) => match v {
            OfficialGamePropVar::P => "ModalFormula.p".to_string(),
            OfficialGamePropVar::Q => "ModalFormula.q".to_string(),
            OfficialGamePropVar::R => "ModalFormula.r".to_string(),
            OfficialGamePropVar::S => "ModalFormula.s".to_string(),
        },
        Formula::True => "ModalFormula.var (KripkeGameVars.p) |> ModalFormula.or (ModalFormula.not (ModalFormula.var (KripkeGameVars.p)))".to_string(),
        Formula::False => "ModalFormula.var (KripkeGameVars.p) |> ModalFormula.and (ModalFormula.not (ModalFormula.var (KripkeGameVars.p)))".to_string(),
        Formula::Not(inner) => format!("ModalFormula.not ({})", formula_to_lean(inner)),
        Formula::MBox(inner) => format!("ModalFormula.box ({})", formula_to_lean(inner)),
        Formula::MDia(inner) => format!("ModalFormula.dia ({})", formula_to_lean(inner)),
        Formula::And(left, right) => {
            format!("ModalFormula.and ({}) ({})", formula_to_lean(left), formula_to_lean(right))
        }
        Formula::Or(left, right) => {
            format!("ModalFormula.or ({}) ({})", formula_to_lean(left), formula_to_lean(right))
        }
        Formula::Imp(left, right) => {
            format!(
                "ModalFormula.implies ({}) ({})",
                formula_to_lean(left),
                formula_to_lean(right)
            )
        }
        Formula::Iff(left, right) => {
            // φ ↔ ψ is (φ → ψ) ∧ (ψ → φ)
            format!(
                "ModalFormula.and (ModalFormula.implies ({}) ({})) (ModalFormula.implies ({}) ({}))",
                formula_to_lean(left),
                formula_to_lean(right),
                formula_to_lean(right),
                formula_to_lean(left)
            )
        }
    }
}

/// Convert a strategy to Lean KripkeGamePartialStrategy syntax
/// Returns the strategy code without the leading indent (caller adds indent)
fn strategy_to_lean(strategy: &StrategyAgainstFixedWorldCount, indent: usize) -> String {
    let indent_str = "  ".repeat(indent);
    match strategy {
        StrategyAgainstFixedWorldCount::ProceedWithExhaustiveSearch => {
            "KripkeGamePartialStrategy.proceedWithExhaustiveSearch".to_string()
        }
        StrategyAgainstFixedWorldCount::AskQueryAndThen { query, cont } => {
            let query_str = formula_to_lean(query);

            // Collect strategies for all possible answers (0 to 4 for frame size 4)
            let strategies: Vec<String> = (0..=4u8)
                .map(|answer| {
                    let strategy_for_answer = cont
                        .get(&answer)
                        .map(|boxed| boxed.as_ref())
                        .unwrap_or(&StrategyAgainstFixedWorldCount::ProceedWithExhaustiveSearch);
                    strategy_to_lean(strategy_for_answer, indent + 1)
                })
                .collect();

            // Generate the array of strategies
            let array_str = if strategies.iter().all(|s| s.len() < 50 && !s.contains('\n')) {
                // Short strategies: put on one line
                format!("#[{}]", strategies.join(", "))
            } else {
                // Long strategies: put on multiple lines
                let items = strategies
                    .iter()
                    .map(|s| format!("\n{}  {}", indent_str, s))
                    .collect::<Vec<_>>()
                    .join(",");
                format!("#[{}{}]", items, format!("\n{}", indent_str))
            };

            format!(
                "(KripkeGamePartialStrategy.askQueryAndThen\n{}  ({})\n{}  {})",
                indent_str, query_str, indent_str, array_str
            )
        }
    }
}

fn main() -> std::io::Result<()> {
    eprintln!("Computing winning strategy...");
    let strategy = come_up_with_strategy();

    eprintln!("Generating Lean code...");
    let stdout = io::stdout();
    let mut output = stdout.lock();

    // Write file header
    writeln!(
        output,
        "-- DO NOT EDIT MANUALLY: Autogenerated by the Kripke Game solver in `/solver`"
    )?;
    writeln!(output)?;
    writeln!(output, "import KripkeGameAnalysis.Game.Strategy.Basic")?;
    writeln!(output)?;

    // Generate strategies for each accessibility relation size
    writeln!(output, "namespace KripkeGameAnalysis.Generated")?;
    writeln!(output)?;

    // For each relation count, generate the strategy (0 to 15, total 16)
    for relation_count in 0u8..=15 {
        if let Some(strategy_for_count) = strategy.0.get(&relation_count) {
            eprintln!(
                "  Generating strategy for relation count {}...",
                relation_count
            );
            writeln!(
                output,
                "def strategy_for_relation_count_{} : KripkeGamePartialStrategy 4 :=",
                relation_count
            )?;
            writeln!(output, "  {}", strategy_to_lean(strategy_for_count, 1))?;
            writeln!(output)?;
        }
    }

    // Generate the strategies array
    writeln!(
        output,
        "def strategies : Array (KripkeGamePartialStrategy 4) :="
    )?;
    write!(output, "  #[")?;
    for relation_count in 0u8..=15 {
        if relation_count > 0 {
            write!(output, ",")?;
        }
        writeln!(output)?;
        write!(
            output,
            "     strategy_for_relation_count_{}",
            relation_count
        )?;
    }
    writeln!(output)?;
    writeln!(output, "   ]")?;
    writeln!(output)?;

    // Generate the dispatcher function
    writeln!(output, "/--")?;
    writeln!(
        output,
        "Select the appropriate strategy based on the accessibility relation size."
    )?;
    writeln!(output, "-/")?;
    writeln!(
        output,
        "def strategyForRelationCount (relCount : Fin 16) : KripkeGamePartialStrategy 4 := strategies[relCount]"
    )?;
    writeln!(output)?;

    writeln!(output, "end KripkeGameAnalysis.Generated")?;

    eprintln!("Successfully generated Lean strategy");
    Ok(())
}

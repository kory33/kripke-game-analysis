extern crate kripke_game_solver;

use kripke_game_solver::formula::Formula;
use kripke_game_solver::offical_game_solver::{
    OfficialGamePropVar, StrategyAgainstFixedWorldCount, come_up_with_strategy,
};
use std::io::{self, Write};

/// Convert a Rust formula to Lean ModalFormula syntax
fn formula_to_lean(f: &Formula<OfficialGamePropVar>) -> String {
    match f {
        Formula::Var(v) => match v {
            OfficialGamePropVar::P => "ModalFormula.p".to_string(),
            OfficialGamePropVar::Q => "ModalFormula.q".to_string(),
            OfficialGamePropVar::R => "ModalFormula.r".to_string(),
            OfficialGamePropVar::S => "ModalFormula.s".to_string(),
        },
        Formula::True => "ModalFormula.var (KripkeGameVars.p) |> ModalFormula.or (ModalFormula.not (ModalFormula.var (KripkeGameVars.p)))".to_string(),
        Formula::False => "ModalFormula.var (KripkeGameVars.p) |> ModalFormula.and (ModalFormula.not (ModalFormula.var (KripkeGameVars.p)))".to_string(),
        Formula::Not(inner) => format!("ModalFormula.not ({})", formula_to_lean(inner)),
        Formula::MBox(inner) => format!("ModalFormula.box ({})", formula_to_lean(inner)),
        Formula::MDia(inner) => format!("ModalFormula.dia ({})", formula_to_lean(inner)),
        Formula::And(left, right) => {
            format!("ModalFormula.and ({}) ({})", formula_to_lean(left), formula_to_lean(right))
        }
        Formula::Or(left, right) => {
            format!("ModalFormula.or ({}) ({})", formula_to_lean(left), formula_to_lean(right))
        }
        Formula::Imp(left, right) => {
            format!(
                "ModalFormula.implies ({}) ({})",
                formula_to_lean(left),
                formula_to_lean(right)
            )
        }
        Formula::Iff(left, right) => {
            // φ ↔ ψ is (φ → ψ) ∧ (ψ → φ)
            format!(
                "ModalFormula.and (ModalFormula.implies ({}) ({})) (ModalFormula.implies ({}) ({}))",
                formula_to_lean(left),
                formula_to_lean(right),
                formula_to_lean(right),
                formula_to_lean(left)
            )
        }
    }
}

/// Convert a strategy to Lean KripkeGameStrategy syntax
/// Returns the strategy code without the leading indent (caller adds indent)
fn strategy_to_lean(strategy: &StrategyAgainstFixedWorldCount, indent: usize) -> String {
    let indent_str = "  ".repeat(indent);
    match strategy {
        StrategyAgainstFixedWorldCount::ProceedWithExhaustiveSearch => {
            "KripkeGameStrategy.proceedWithExhaustiveSearch".to_string()
        }
        StrategyAgainstFixedWorldCount::AskQueryAndThen { query, cont } => {
            let query_str = formula_to_lean(query);
            let mut result = format!(
                "(KripkeGameStrategy.askQueryAndThen\n{}  ({})\n{}  (fun answer => match answer with",
                indent_str, query_str, indent_str
            );

            // Generate match cases for all possible answers (0 to 4 for frame size 4)
            for answer in 0..=4u8 {
                let strategy_for_answer = cont
                    .get(&answer)
                    .map(|boxed| boxed.as_ref())
                    .unwrap_or(&StrategyAgainstFixedWorldCount::ProceedWithExhaustiveSearch);

                result.push_str(&format!(
                    "\n{}  | {} => {}",
                    indent_str,
                    answer,
                    strategy_to_lean(strategy_for_answer, indent + 2)
                ));
            }

            result.push_str(&format!("\n{}  ))", indent_str));
            result
        }
    }
}

fn main() -> std::io::Result<()> {
    eprintln!("Computing winning strategy...");
    let strategy = come_up_with_strategy();

    eprintln!("Generating Lean code...");
    let stdout = io::stdout();
    let mut output = stdout.lock();

    // Write file header
    writeln!(
        output,
        "-- DO NOT EDIT MANUALLY: Autogenerated by the Kripke Game solver in `/solver`"
    )?;
    writeln!(output)?;
    writeln!(output, "import KripkeGameAnalysis.Game.Strategy.Basic")?;
    writeln!(output)?;

    // Generate strategies for each accessibility relation size
    writeln!(output, "namespace KripkeGameAnalysis.Generated")?;
    writeln!(output)?;

    // For each relation count, generate the strategy
    for relation_count in 0u8..=16 {
        if let Some(strategy_for_count) = strategy.0.get(&relation_count) {
            eprintln!(
                "  Generating strategy for relation count {}...",
                relation_count
            );
            writeln!(
                output,
                "def strategy_for_relation_count_{} : KripkeGameStrategy 4 :=",
                relation_count
            )?;
            writeln!(output, "  {}", strategy_to_lean(strategy_for_count, 1))?;
            writeln!(output)?;
        }
    }

    // Generate the dispatcher function
    writeln!(output, "/--")?;
    writeln!(
        output,
        "Select the appropriate strategy based on the accessibility relation size."
    )?;
    writeln!(output, "-/")?;
    writeln!(
        output,
        "def selectStrategyForRelationCount (relCount : Fin 17) : KripkeGameStrategy 4 :="
    )?;
    writeln!(output, "  match relCount.val with")?;
    for relation_count in 0u8..=16 {
        writeln!(
            output,
            "  | {} => strategy_for_relation_count_{}",
            relation_count, relation_count
        )?;
    }
    writeln!(
        output,
        "  | _ => strategy_for_relation_count_0  -- unreachable"
    )?;
    writeln!(output)?;

    writeln!(output, "end KripkeGameAnalysis.Generated")?;

    eprintln!("Successfully generated Lean strategy");
    Ok(())
}

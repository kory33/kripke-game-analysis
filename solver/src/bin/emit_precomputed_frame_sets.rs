extern crate kripke_game_solver;

use kripke_game_solver::finite_kripke_frame::FiniteKripkeFrame;
use std::io::{self, Write};

fn main() -> std::io::Result<()> {
    eprintln!("Computing canonical frames...");
    let canonical_frames = FiniteKripkeFrame::<4>::canonical_frames();
    eprintln!("Found {} canonical frames", canonical_frames.len());

    eprintln!("Grouping frames by accessibility relation count...");
    let grouped = FiniteKripkeFrame::<4>::canonical_frames_grouped_by_accessibility_count();

    eprintln!("Generating Lean code...");
    let stdout = io::stdout();
    let mut output = stdout.lock();

    // Write file header
    writeln!(
        output,
        "-- DO NOT EDIT MANUALLY: Autogenerated by the Kripke Game solver in `/solver`"
    )?;
    writeln!(output)?;
    writeln!(
        output,
        "import KripkeGameAnalysis.Game.Strategy.gen.PrecomputedFrameSetsDefsAndLemmas"
    )?;
    writeln!(output)?;

    writeln!(output, "namespace KripkeGameAnalysis.Precomputed")?;
    writeln!(output)?;

    // Add NeZero instance for 65536
    writeln!(output, "instance : NeZero 65536 := ⟨by decide⟩")?;
    writeln!(output)?;

    // Increase recursion depth and heartbeats for large computations
    writeln!(output, "set_option maxRecDepth 10000")?;
    writeln!(output, "set_option maxHeartbeats 1000000")?;
    writeln!(output)?;

    // Generate array of all frame IDs as Nats (split into chunks to avoid recursion depth)
    writeln!(output, "/--")?;
    writeln!(
        output,
        "All frame IDs as an array of Nats (for efficient elaboration)."
    )?;
    writeln!(output, "-/")?;

    // Split into chunks of 100 to avoid recursion depth issues
    const CHUNK_SIZE: usize = 100;
    let num_chunks = (canonical_frames.len() + CHUNK_SIZE - 1) / CHUNK_SIZE;

    for chunk_idx in 0..num_chunks {
        let start = chunk_idx * CHUNK_SIZE;
        let end = ((chunk_idx + 1) * CHUNK_SIZE).min(canonical_frames.len());

        writeln!(
            output,
            "private def allFrameIdsChunk{} : Array Nat :=",
            chunk_idx
        )?;
        write!(output, "  #[")?;

        for (i, frame) in canonical_frames[start..end].iter().enumerate() {
            if i > 0 {
                write!(output, ", ")?;
            }
            if i % 8 == 0 {
                writeln!(output)?;
                write!(output, "    ")?;
            }
            let id = frame.to_u16_id();
            write!(output, "{}", id)?;
        }
        writeln!(output)?;
        writeln!(output, "  ]")?;
        writeln!(output)?;
    }

    // Concatenate all chunks
    writeln!(output, "def allFrameIdsArrayNat : Array Nat :=")?;
    for chunk_idx in 0..num_chunks {
        if chunk_idx == 0 {
            write!(output, "  allFrameIdsChunk{}", chunk_idx)?;
        } else {
            writeln!(output)?;
            write!(output, "  ++ allFrameIdsChunk{}", chunk_idx)?;
        }
    }
    writeln!(output)?;
    writeln!(output)?;

    // Convert to Finset of Fin 65536
    writeln!(output, "/--")?;
    writeln!(
        output,
        "All frame IDs as a Finset (converting from Nat to Fin)."
    )?;
    writeln!(output, "-/")?;
    writeln!(output, "def allFrameIdsSet : Finset (Fin 65536) :=")?;
    writeln!(
        output,
        "  (allFrameIdsArrayNat.map (fun n => Fin.mk (n % 65536) (Nat.mod_lt n (by decide : 0 < 65536)))).toList.toFinset"
    )?;
    writeln!(output)?;

    // Generate theorems about all frames
    writeln!(output, "theorem allFramesUptoIso_4_as_ids :")?;
    writeln!(
        output,
        "    (FiniteKripkeFrame.UptoIso.univ 4).map frameToId = allFrameIdsSet := by"
    )?;
    writeln!(
        output,
        "  -- This theorem is quite expensive to prove. I (kory33) doubt this could be done with `decide` alone."
    )?;
    writeln!(output, "  native_decide")?;
    writeln!(output)?;

    writeln!(output, "theorem allFramesUptoIso_4 :")?;
    writeln!(
        output,
        "    (FiniteKripkeFrame.UptoIso.univ 4) = allFrameIdsSet.image idToFrameEquivClass := by"
    )?;
    writeln!(output, "  rw [← allFramesUptoIso_4_as_ids]")?;
    writeln!(
        output,
        "  rw [map_image_retract_eq _ _ (fun c => idToFrameEquivClass_retr c) _]"
    )?;
    writeln!(output)?;

    // Generate 17 theorems for each accessibility relation count (0 to 16)
    for relation_count in 0u8..=16 {
        eprintln!(
            "  Generating theorem for relation count {}...",
            relation_count
        );

        let frames_for_count = grouped.get(&relation_count);
        let frame_ids: Vec<u16> = if let Some(frames) = frames_for_count {
            frames.iter().map(|f| f.to_u16_id()).collect()
        } else {
            Vec::new()
        };

        // Generate array for this relation count (as Nat, split into chunks)
        writeln!(output, "/--")?;
        writeln!(
            output,
            "Frame IDs with {} accessibility relations (as Nat array).",
            relation_count
        )?;
        writeln!(output, "-/")?;

        if frame_ids.is_empty() {
            writeln!(
                output,
                "def frameIdsArrayNat_{} : Array Nat := #[]",
                relation_count
            )?;
            writeln!(output)?;
        } else if frame_ids.len() <= CHUNK_SIZE {
            // Small enough, no chunking needed
            writeln!(
                output,
                "def frameIdsArrayNat_{} : Array Nat :=",
                relation_count
            )?;
            write!(output, "  #[")?;
            for (i, &id) in frame_ids.iter().enumerate() {
                if i > 0 {
                    write!(output, ", ")?;
                }
                if i % 8 == 0 {
                    writeln!(output)?;
                    write!(output, "    ")?;
                }
                write!(output, "{}", id)?;
            }
            writeln!(output)?;
            writeln!(output, "  ]")?;
            writeln!(output)?;
        } else {
            // Need chunking
            let num_chunks = (frame_ids.len() + CHUNK_SIZE - 1) / CHUNK_SIZE;

            for chunk_idx in 0..num_chunks {
                let start = chunk_idx * CHUNK_SIZE;
                let end = ((chunk_idx + 1) * CHUNK_SIZE).min(frame_ids.len());

                writeln!(
                    output,
                    "private def frameIdsChunk_{}_{} : Array Nat :=",
                    relation_count, chunk_idx
                )?;
                write!(output, "  #[")?;

                for (i, &id) in frame_ids[start..end].iter().enumerate() {
                    if i > 0 {
                        write!(output, ", ")?;
                    }
                    if i % 8 == 0 {
                        writeln!(output)?;
                        write!(output, "    ")?;
                    }
                    write!(output, "{}", id)?;
                }
                writeln!(output)?;
                writeln!(output, "  ]")?;
                writeln!(output)?;
            }

            // Concatenate chunks
            writeln!(
                output,
                "def frameIdsArrayNat_{} : Array Nat :=",
                relation_count
            )?;
            for chunk_idx in 0..num_chunks {
                if chunk_idx == 0 {
                    write!(output, "  frameIdsChunk_{}_{}", relation_count, chunk_idx)?;
                } else {
                    writeln!(output)?;
                    write!(
                        output,
                        "  ++ frameIdsChunk_{}_{}",
                        relation_count, chunk_idx
                    )?;
                }
            }
            writeln!(output)?;
            writeln!(output)?;
        }

        // Convert to Finset
        writeln!(
            output,
            "def frameIdsSet_{} : Finset (Fin 65536) :=",
            relation_count
        )?;
        writeln!(
            output,
            "  (frameIdsArrayNat_{}.map (fun n => Fin.mk (n % 65536) (Nat.mod_lt n (by decide : 0 < 65536)))).toList.toFinset",
            relation_count
        )?;
        writeln!(output)?;

        // Generate the main theorem for possibleFramesUptoIso
        // All theorems use the optimized pattern (work at ID level, not equivalence class level)
        writeln!(
            output,
            "theorem possibleFramesUptoIso_initial_state_{} :",
            relation_count
        )?;
        writeln!(
            output,
            "  ({{ accessiblityRelationSize := ⟨{}, lt_witness⟩, queriesAndAnswers := [] }} : KripkeGameVisibleState 4).possibleFramesUptoIso =",
            relation_count
        )?;
        writeln!(
            output,
            "    frameIdsSet_{}.image idToFrameEquivClass := by",
            relation_count
        )?;
        writeln!(
            output,
            "  have : (lt_witness = (by decide)) := rfl; rw [this]; clear * - -- get rid of lt_witness"
        )?;
        writeln!(
            output,
            "  simp only [KripkeGameVisibleState.possibleFramesUptoIso, List.all_nil, and_true]"
        )?;
        writeln!(output, "  rw [allFramesUptoIso_4]")?;
        writeln!(output, "  dsimp only [KripkeGameVisibleState.frameSize]")?;
        writeln!(output, "  rw [filter_image_eq_image_filter")?;
        writeln!(output, "      (s := allFrameIdsSet)")?;
        writeln!(output, "      (f := idToFrameEquivClass)")?;
        writeln!(
            output,
            "      (p₁ := fun frame => {} = frame.accessibilityRelationCount)",
            relation_count
        )?;
        writeln!(
            output,
            "      (p₂ := fun id => frameIdToRelCount id = {})",
            relation_count
        )?;
        writeln!(
            output,
            "      (h := fun id => by grind [frameIdToRelCount_spec])"
        )?;
        writeln!(output, "  ]")?;
        writeln!(output, "  apply congrArg")?;
        writeln!(output, "  native_decide")?;
        writeln!(output)?;
    }

    writeln!(output, "end KripkeGameAnalysis.Precomputed")?;

    eprintln!("Successfully generated precomputed frame sets");
    Ok(())
}
